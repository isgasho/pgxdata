package data

// This file is automatically generated by pgxdata.

import (
	"context"
	"strings"

	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

type Customer struct {
	ID           pgtype.Int4
	FirstName    pgtype.Varchar
	LastName     pgtype.Varchar
	BirthDate    pgtype.Date
	CreationTime pgtype.Timestamptz
}

const countCustomerSQL = `select count(*) from "customer"`

func CountCustomer(ctx context.Context, db Queryer) (int64, error) {
	var n int64
	err := prepareQueryRow(ctx, db, "pgxdataCountCustomer", countCustomerSQL).Scan(&n)
	return n, err
}

const SelectAllCustomerSQL = `select
  "id",
  "first_name",
  "last_name",
  "birth_date",
  "creation_time"
from "customer"`

func SelectAllCustomer(ctx context.Context, db Queryer) ([]Customer, error) {
	var rows []Customer

	dbRows, err := prepareQuery(ctx, db, "pgxdataSelectAllCustomer", SelectAllCustomerSQL)
	if err != nil {
		return nil, err
	}

	for dbRows.Next() {
		var row Customer
		dbRows.Scan(
			&row.ID,
			&row.FirstName,
			&row.LastName,
			&row.BirthDate,
			&row.CreationTime,
		)
		rows = append(rows, row)
	}

	if dbRows.Err() != nil {
		return nil, dbRows.Err()
	}

	return rows, nil
}

const selectCustomerByPKSQL = `select
  "id",
  "first_name",
  "last_name",
  "birth_date",
  "creation_time"
from "customer"
where "id"=$1`

func SelectCustomerByPK(
	ctx context.Context,
	db Queryer,
	id int32,
) (*Customer, error) {
	var row Customer
	err := prepareQueryRow(ctx, db, "pgxdataSelectCustomerByPK", selectCustomerByPKSQL, id).Scan(
		&row.ID,
		&row.FirstName,
		&row.LastName,
		&row.BirthDate,
		&row.CreationTime,
	)
	if err == pgx.ErrNoRows {
		return nil, ErrNotFound
	} else if err != nil {
		return nil, err
	}

	return &row, nil
}

func InsertCustomer(ctx context.Context, db Queryer, row *Customer) error {
	args := pgx.QueryArgs(make([]interface{}, 0, 5))

	var columns, values []string

	if row.ID.Status != pgtype.Undefined {
		columns = append(columns, `id`)
		values = append(values, args.Append(&row.ID))
	}
	if row.FirstName.Status != pgtype.Undefined {
		columns = append(columns, `first_name`)
		values = append(values, args.Append(&row.FirstName))
	}
	if row.LastName.Status != pgtype.Undefined {
		columns = append(columns, `last_name`)
		values = append(values, args.Append(&row.LastName))
	}
	if row.BirthDate.Status != pgtype.Undefined {
		columns = append(columns, `birth_date`)
		values = append(values, args.Append(&row.BirthDate))
	}
	if row.CreationTime.Status != pgtype.Undefined {
		columns = append(columns, `creation_time`)
		values = append(values, args.Append(&row.CreationTime))
	}

	sql := `insert into "customer"(` + strings.Join(columns, ", ") + `)
values(` + strings.Join(values, ",") + `)
returning "id"
  `

	psName := preparedName("pgxdataInsertCustomer", sql)

	return prepareQueryRow(ctx, db, psName, sql, args...).Scan(&row.ID)
}

func UpdateCustomer(ctx context.Context, db Queryer,
	id int32,
	row *Customer,
) error {
	sets := make([]string, 0, 5)
	args := pgx.QueryArgs(make([]interface{}, 0, 5))

	if row.ID.Status != pgtype.Undefined {
		sets = append(sets, `id`+"="+args.Append(&row.ID))
	}
	if row.FirstName.Status != pgtype.Undefined {
		sets = append(sets, `first_name`+"="+args.Append(&row.FirstName))
	}
	if row.LastName.Status != pgtype.Undefined {
		sets = append(sets, `last_name`+"="+args.Append(&row.LastName))
	}
	if row.BirthDate.Status != pgtype.Undefined {
		sets = append(sets, `birth_date`+"="+args.Append(&row.BirthDate))
	}
	if row.CreationTime.Status != pgtype.Undefined {
		sets = append(sets, `creation_time`+"="+args.Append(&row.CreationTime))
	}

	if len(sets) == 0 {
		return nil
	}

	sql := `update "customer" set ` + strings.Join(sets, ", ") + ` where ` + `"id"=` + args.Append(id)

	psName := preparedName("pgxdataUpdateCustomer", sql)

	commandTag, err := prepareExec(ctx, db, psName, sql, args...)
	if err != nil {
		return err
	}
	if commandTag.RowsAffected() != 1 {
		return ErrNotFound
	}
	return nil
}

func DeleteCustomer(ctx context.Context, db Queryer,
	id int32,
) error {
	args := pgx.QueryArgs(make([]interface{}, 0, 1))

	sql := `delete from "customer" where ` + `"id"=` + args.Append(id)

	commandTag, err := prepareExec(ctx, db, "pgxdataDeleteCustomer", sql, args...)
	if err != nil {
		return err
	}
	if commandTag.RowsAffected() != 1 {
		return ErrNotFound
	}
	return nil
}
