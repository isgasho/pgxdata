package data

// This file is automatically generated by pgxdata.

import (
	"context"
	"strings"

	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
	errors "golang.org/x/xerrors"
)

type Part struct {
	Code        pgtype.Varchar
	Description pgtype.Text
}

const countPartSQL = `select count(*) from "part"`

func CountPart(ctx context.Context, db Queryer) (int64, error) {
	var n int64
	err := prepareQueryRow(ctx, db, "pgxdataCountPart", countPartSQL).Scan(&n)
	return n, err
}

const SelectAllPartSQL = `select
  "code",
  "description"
from "part"`

func SelectAllPart(ctx context.Context, db Queryer) ([]Part, error) {
	var rows []Part

	dbRows, err := prepareQuery(ctx, db, "pgxdataSelectAllPart", SelectAllPartSQL)
	if err != nil {
		return nil, err
	}

	for dbRows.Next() {
		var row Part
		dbRows.Scan(
			&row.Code,
			&row.Description,
		)
		rows = append(rows, row)
	}

	if dbRows.Err() != nil {
		return nil, dbRows.Err()
	}

	return rows, nil
}

const selectPartByPKSQL = `select
  "code",
  "description"
from "part"
where "code"=$1`

func SelectPartByPK(
	ctx context.Context,
	db Queryer,
	code string,
) (*Part, error) {
	var row Part
	err := prepareQueryRow(ctx, db, "pgxdataSelectPartByPK", selectPartByPKSQL, code).Scan(
		&row.Code,
		&row.Description,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, ErrNotFound
	} else if err != nil {
		return nil, err
	}

	return &row, nil
}

func InsertPart(ctx context.Context, db Queryer, row *Part) error {
	args := pgx.QueryArgs(make([]interface{}, 0, 2))

	var columns, values []string

	if row.Code.Status != pgtype.Undefined {
		columns = append(columns, `code`)
		values = append(values, args.Append(&row.Code))
	}
	if row.Description.Status != pgtype.Undefined {
		columns = append(columns, `description`)
		values = append(values, args.Append(&row.Description))
	}

	sql := `insert into "part"(` + strings.Join(columns, ", ") + `)
values(` + strings.Join(values, ",") + `)
returning "code"
  `

	psName := preparedName("pgxdataInsertPart", sql)

	return prepareQueryRow(ctx, db, psName, sql, args...).Scan(&row.Code)
}

func UpdatePart(ctx context.Context, db Queryer,
	code string,
	row *Part,
) error {
	sets := make([]string, 0, 2)
	args := pgx.QueryArgs(make([]interface{}, 0, 2))

	if row.Code.Status != pgtype.Undefined {
		sets = append(sets, `code`+"="+args.Append(&row.Code))
	}
	if row.Description.Status != pgtype.Undefined {
		sets = append(sets, `description`+"="+args.Append(&row.Description))
	}

	if len(sets) == 0 {
		return nil
	}

	sql := `update "part" set ` + strings.Join(sets, ", ") + ` where ` + `"code"=` + args.Append(code)

	psName := preparedName("pgxdataUpdatePart", sql)

	commandTag, err := prepareExec(ctx, db, psName, sql, args...)
	if err != nil {
		return err
	}
	if commandTag.RowsAffected() != 1 {
		return ErrNotFound
	}
	return nil
}

func DeletePart(ctx context.Context, db Queryer,
	code string,
) error {
	args := pgx.QueryArgs(make([]interface{}, 0, 1))

	sql := `delete from "part" where ` + `"code"=` + args.Append(code)

	commandTag, err := prepareExec(ctx, db, "pgxdataDeletePart", sql, args...)
	if err != nil {
		return err
	}
	if commandTag.RowsAffected() != 1 {
		return ErrNotFound
	}
	return nil
}
